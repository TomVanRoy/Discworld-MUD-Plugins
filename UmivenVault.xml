<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Vault Tracker created by Umiven -->
<muclient>
<plugin
   name="UmivenVault"
   author="Umiven"
   id="556d6976656e000000000002"
   language="Lua"
   purpose="Vault Tracker"
   date_written="2022-05-27"
   date_modified="2022-08-30"
   save_state="y"
   requires="5.06"
   version="1.03"
   >
</plugin>

<script>
<![CDATA[
-- ********************************************************************
-- *****                      Vault Tracker                       *****
-- *****                      For Discworld                       *****
-- *****                  !! REQUIRES COWBAR !!                   *****
-- *****                                                          *****
-- *****  Keeps track of the all items in your vaults. To use     *****
-- *****  this plugin, go to each vault and look at the items in  *****
-- *****  each vault. The items will then be stored per vault.    *****
-- *****  'vault' or 'vaults' returns a list of vaults, along     *****
-- *****  with options to see its contents (if it has any) and a  *****
-- *****  button to speedwalk to it.                              *****
-- *****  'vault <item>' or 'vaults <item>' will return a list of *****
-- *****  vaults that contain the specified item.                 *****
-- *****  'vaultall' or 'vaultsall' will return a combined list   *****
-- *****  of every item and the amount of it you have across all  *****
-- *****  vaults.                                                 *****
-- ********************************************************************

--#region database
local vaults = {
	["Nella's vault"] = {order = 1, city = "Ankh-Morpork", location = "Barbican Plaza", cost = "30p", container = "large wooden drawer"},
	["opulent office"] = {order = 2, city = "Ankh-Morpork", location = "The Ridings", cost = "30p", container = "cubby hole"},
	["small garden"] = {order = 3, city = "Bes Pelargic", location = "Way of the Dragon", cost = "50s", container = "clean nest"},
	["Thella's vault"] = {order = 4, city = "Djelibeybi", location = "Scarab Walk", cost = "DjToon 0.50", container = "drawer"},
	["cool, dry basement"] = {order = 5, city = "Ephebe", location = "Logical Lane", cost = "50de", container = "octiron tesseract"},
	["safety deposit waiting room"] = {order = 6, city = "Genua", location = "Royal Avenue", cost = "66Gc", container = "steel locker"},
	["office in Ohulan-Cutash"] = {order = 7, city = "Ohulan Cutash", location = "Dock Street", cost = "Lp 10", container = "cubby hole"},
}
local itemsEndingInES = {
	"breezes",
	"daisies",
	"dentures",
	"edges",
	"eyes",
	"leaves",
	"mcnoodles",
	"noodles",
	"misshapes",
	"nightshades",
	"peonies",
	"rushes",
	"sauternes",
	"spangles",
	"speckles",
	"squares",
	"supplies",
}
local itemsEndingInS = {
	"abacus",
	"accents",
	"adventurers",
	"aegis",
	"albatross",
	"almonds",
	"ambergris",
	"arms",
	"atlas",
	"aulos",
	"balloons",
	"balls",
	"bass",
	"beads",
	"beans",
	"bears",
	"beets",
	"beginners",
	"bells",
	"bits",
	"blocks",
	"bolognas",
	"bolts",
	"breasts",
	"burnous",
	"buttons",
	"cactus",
	"candyfloss",
	"cards",
	"carrots",
	"cereus",
	"chains",
	"chestnuts",
	"chews",
	"chickpeas",
	"chips",
	"chlamys",
	"cigars",
	"clams",
	"claws",
	"clematis",
	"cocktails",
	"compass",
	"couscous",
	"crackers",
	"crayons",
	"crisps",
	"cross",
	"croutons",
	"cuirass",
	"cupboards",
	"cushions",
	"cutlass",
	"cypress",
	"daffodils",
	"drawers",
	"dress",
	"droppings",
	"ducks",
	"dumplings",
	"earflaps",
	"ears",
	"eggs",
	"entrails",
	"escargots",
	"exomis",
	"famous",
	"feathers",
	"fields",
	"filings",
	"fingers",
	"flanchards",
	"floris",
	"floss",
	"flowers",
	"forests",
	"fours",
	"freesias",
	"fruits",
	"gibus",
	"gladiolus",
	"gladius",
	"glass",
	"goddess",
	"grass",
	"guinness",
	"haggis",
	"haikus",
	"handcuffs",
	"hands",
	"harness",
	"headdress",
	"hourglass",
	"iris",
	"jewels",
	"kalasiris",
	"kopis",
	"labels",
	"legs",
	"lens",
	"lentils",
	"lights",
	"liqueurs",
	"llamedos",
	"lotus",
	"lumps",
	"madness",
	"mantis",
	"mass",
	"mess",
	"minidress",
	"moons",
	"moss",
	"mushrooms",
	"mussels",
	"nails",
	"neckirons",
	"nightdress",
	"nuts",
	"oats",
	"obolus",
	"octopus",
	"orchids",
	"overalls",
	"oysters",
	"pants",
	"papers",
	"papyrus",
	"pass",
	"peanuts",
	"pecans",
	"peplos",
	"petticoats",
	"plains",
	"poems",
	"quilters",
	"rags",
	"ramtops",
	"ravens",
	"realms",
	"ribbons",
	"ribs",
	"rinds",
	"rocks",
	"roots",
	"sagaris",
	"sarcophagus",
	"schnapps",
	"scraps",
	"scratchings",
	"sequins",
	"sheets",
	"shells",
	"shepherdess",
	"shoots",
	"shotglass",
	"shreddings",
	"spirits",
	"starflowers",
	"sticks",
	"streamers",
	"stylus",
	"sundress",
	"sunflowers",
	"swampgas",
	"tacticus",
	"tails",
	"tears",
	"tickets",
	"tongs",
	"tools",
	"twigs",
	"underdress",
	"veils",
	"violets",
	"waders",
	"walnuts",
	"washers",
	"weeds",
	"whelks",
	"whiskers",
	"wings",
	"worms",
	"wristlets",
	"xiphos",
}
local itemsEndingInE = {
	"abalone",
	"absinthe",
	"adhesive",
	"akome",
	"ale",
	"ankhstone",
	"apple",
	"applique",
	"armoire",
	"artichoke",
	"attire",
	"aubergine",
	"axe",
	"axle",
	"badge",
	"bagpipe",
	"balance",
	"bangle",
	"bathrobe",
	"bauble",
	"beagle",
	"beanie",
	"beetle",
	"bite",
	"blade",
	"bloodstone",
	"blouse",
	"blowpipe",
	"blue",
	"bodice",
	"bolognese",
	"bone",
	"bookcase",
	"bootlace",
	"borage",
	"bottle",
	"bouteille",
	"boutonniere",
	"brassiere",
	"breastplate",
	"breeze",
	"brie",
	"briefcase",
	"brochure",
	"brulee",
	"bubble",
	"buckle",
	"buttonhole",
	"cabbage",
	"cage",
	"cake",
	"camisole",
	"candle",
	"cane",
	"cape",
	"capsule",
	"carapace",
	"case",
	"castle",
	"catalogue",
	"cervilliere",
	"champagne",
	"cheese",
	"cheesecake",
	"cheesewire",
	"chime",
	"chocolate",
	"choice",
	"cigarette",
	"claymore",
	"cobble",
	"cockle",
	"coffee",
	"colichemarde",
	"collie",
	"cone",
	"cookie",
	"cookstove",
	"corniche",
	"corpse",
	"corsage",
	"costume",
	"crane",
	"crate",
	"crepe",
	"crinoline",
	"crocodile",
	"crumble",
	"cube",
	"cupcake",
	"cure",
	"custome",
	"date",
	"device",
	"dice",
	"die",
	"drawknife",
	"drynke",
	"duckie",
	"dune",
	"dye",
	"engine",
	"ensemble",
	"envelope",
	"epee",
	"ephebe",
	"escritoire",
	"eztope",
	"face",
	"femme",
	"figure",
	"figurine",
	"file",
	"finale",
	"fire",
	"fireplace",
	"fleece",
	"flute",
	"folle",
	"foxglove",
	"frame",
	"frankincense",
	"frisbee",
	"frittole",
	"fromage",
	"fudge",
	"fumee",
	"fuse",
	"game",
	"garbage",
	"gargoyle",
	"gauche",
	"girdle",
	"glaive",
	"globe",
	"glove",
	"glue",
	"gnameplate",
	"gnome",
	"goose",
	"gote",
	"grape",
	"grenouille",
	"guide",
	"handle",
	"headpiece",
	"hellebore",
	"hinge",
	"hive",
	"hoe",
	"horse",
	"horseshoe",
	"hose",
	"impie",
	"incense",
	"indulgence",
	"ire",
	"jasmine",
	"juice",
	"kamikaze",
	"kelpie",
	"kettle",
	"kite",
	"knife",
	"kosode",
	"kote",
	"kourambiethe",
	"lace",
	"ladle",
	"landscape",
	"lasagne",
	"lecture",
	"lemonade",
	"lettuce",
	"licence",
	"lime",
	"line",
	"lingerie",
	"linzerauge",
	"longue",
	"lozenge",
	"luggage",
	"lure",
	"lute",
	"lyre",
	"mace",
	"machine",
	"magazine",
	"mantelpiece",
	"maple",
	"marble",
	"marionette",
	"mcrice",
	"me",
	"measure",
	"megaphone",
	"meringue",
	"milkshake",
	"mistletoe",
	"mitre",
	"mixture",
	"mole",
	"monocle",
	"moonshine",
	"moose",
	"mouse",
	"mousse",
	"moustache",
	"mussie",
	"muzzle",
	"necklace",
	"nectarine",
	"needle",
	"negligee",
	"newbie",
	"nightie",
	"nose",
	"note",
	"numberplate",
	"office",
	"oilstone",
	"oinochoe",
	"olive",
	"olpe",
	"orange",
	"ore",
	"package",
	"palette",
	"pancake",
	"panpipe",
	"pebble",
	"penible",
	"perfume",
	"periwinkle",
	"pestle",
	"philtre",
	"pickaxe",
	"pickle",
	"picture",
	"pie",
	"piece",
	"pinafore",
	"pine",
	"pineapple",
	"pipe",
	"pipette",
	"pishe",
	"plaque",
	"plate",
	"ploughshare",
	"plume",
	"pole",
	"pomegranate",
	"pomperiposse",
	"poodle",
	"porridge",
	"porthole",
	"praline",
	"preserve",
	"protective",
	"purse",
	"rake",
	"range",
	"ratatouille",
	"reticule",
	"rice",
	"ricecake",
	"robe",
	"rope",
	"rose",
	"rosette",
	"royale",
	"sabre",
	"saddle",
	"safe",
	"sage",
	"sake",
	"sandstone",
	"sandwhitche",
	"sauce",
	"sausage",
	"saxophone",
	"scale",
	"scene",
	"sceptre",
	"sconce",
	"scone",
	"sculpture",
	"scumble",
	"scuttle",
	"scythe",
	"seahorse",
	"settee",
	"shake",
	"shingle",
	"shortcake",
	"sickle",
	"sidetable",
	"significance",
	"slate",
	"slice",
	"slide",
	"sludge",
	"slumpie",
	"snake",
	"snausage",
	"snowflake",
	"snowflare",
	"snowglobe",
	"sode",
	"solitaire",
	"sphere",
	"spike",
	"sponge",
	"square",
	"stake",
	"statue",
	"statuette",
	"stile",
	"stole",
	"stone",
	"stove",
	"suitcase",
	"sundae",
	"suneate",
	"sunrise",
	"sunshine",
	"surplice",
	"surprise",
	"swede",
	"swine",
	"switchblade",
	"sycamore",
	"table",
	"tambourine",
	"tangerine",
	"tape",
	"tease",
	"tee",
	"tempscire",
	"tentacle",
	"terre",
	"thimble",
	"thingie",
	"thobe",
	"thyme",
	"tickle",
	"tie",
	"tile",
	"timepiece",
	"tipple",
	"tissue",
	"toffee",
	"toie",
	"toothpaste",
	"tortoise",
	"toupee",
	"tree",
	"triangle",
	"trireme",
	"trombone",
	"truffle",
	"tube",
	"turpentine",
	"turtle",
	"ukulele",
	"vampire",
	"vase",
	"ve",
	"verge",
	"waffle",
	"wallpiece",
	"wardrobe",
	"wedge",
	"whale",
	"whalebone",
	"wheelhouse",
	"whine",
	"whipple",
	"whistle",
	"white",
	"wildride",
	"wine",
	"winkle",
	"wire",
	"withe",
	"wizzie",
	"womble",
	"wossname",
}
local itemsWithComma = {
	"battered, black tricorn",
	"Bes Pelargic Blue tobacco, special import",
	"Buffalo tobacco, the people's choice",
	"cigar baklava, perfect for a late night sugar crash",
	"delicious kebab, fast and cheap",
	"Grims tobacco, for the hardened smoker",
	"hard, pink mass",
	"large, wide-brimmed black hat",
	"long, sharp hatpin",
	"Long, Slow Fish Against A Wall",
	"long, thin needle",
	"old, worn-out broomstick",
	"open, empty briefcase",
	"pair of filmy, clinging, billowing harem trousers",
	"pair of sheer, red silk stockings",
	"paper cup of stewed, cold tea",
	"plain, grey suit jacket",
	"Quirm Red, last year's",
	"Quirm Red, this year's",
	"small, salt-encrusted peanut",
	"sparkling, bejewelled anklet",
	"Two-Hump tobacco, that special taste of Klatch",
}
local numberWords = {
	["zero"] = 0,
	["half"] = 0.5,
	["one"] = 1,
	["two"] = 2,
	["three"] = 3,
	["four"] = 4,
	["five"] = 5,
	["six"] = 6,
	["seven"] = 7,
	["eight"] = 8,
	["nine"] = 9,
	["ten"] = 10,
	["eleven"] = 11,
	["twelve"] = 12,
	["thirteen"] = 13,
	["fourteen"] = 14,
	["fifteen"] = 15,
	["sixteen"] = 16,
	["seventeen"] = 17,
	["eighteen"] = 18,
	["nineteen"] = 19,
	["twenty"] = 20,
	["twenty-one"] = 21,
	["twenty-two"] = 22,
	["twenty-three"] = 23,
	["twenty-four"] = 24,
	["twenty-five"] = 25,
	["twenty-six"] = 26,
	["twenty-seven"] = 27,
	["twenty-eight"] = 28,
	["twenty-nine"] = 29,
	["thirty"] = 30,
	["thirty-one"] = 31,
	["thirty-two"] = 32,
	["thirty-three"] = 33,
	["thirty-four"] = 34,
	["thirty-five"] = 35,
	["thirty-six"] = 36,
	["thirty-seven"] = 37,
	["thirty-eight"] = 38,
	["thirty-nine"] = 39,
	["forty"] = 40,
	["forty-one"] = 41,
	["forty-two"] = 42,
	["forty-three"] = 43,
	["forty-four"] = 44,
	["forty-five"] = 45,
	["forty-six"] = 46,
	["forty-seven"] = 47,
	["forty-eight"] = 48,
	["forty-nine"] = 49,
	["fifty"] = 50,
	["fifty-one"] = 51,
	["fifty-two"] = 52,
	["fifty-three"] = 53,
	["fifty-four"] = 54,
	["fifty-five"] = 55,
	["fifty-six"] = 56,
	["fifty-seven"] = 57,
	["fifty-eight"] = 58,
	["fifty-nine"] = 59,
	["sixty"] = 60,
	["sixty-one"] = 61,
	["sixty-two"] = 62,
	["sixty-three"] = 63,
	["sixty-four"] = 64,
	["sixty-five"] = 65,
	["sixty-six"] = 66,
	["sixty-seven"] = 67,
	["sixty-eight"] = 68,
	["sixty-nine"] = 69,
	["seventy"] = 70,
	["seventy-one"] = 71,
	["seventy-two"] = 72,
	["seventy-three"] = 73,
	["seventy-four"] = 74,
	["seventy-five"] = 75,
	["seventy-six"] = 76,
	["seventy-seven"] = 77,
	["seventy-eight"] = 78,
	["seventy-nine"] = 79,
	["eighty"] = 80,
	["eighty-one"] = 81,
	["eighty-two"] = 82,
	["eighty-three"] = 83,
	["eighty-four"] = 84,
	["eighty-five"] = 85,
	["eighty-six"] = 86,
	["eighty-seven"] = 87,
	["eighty-eight"] = 88,
	["eighty-nine"] = 89,
	["ninety"] = 90,
	["ninety-one"] = 91,
	["ninety-two"] = 92,
	["ninety-three"] = 93,
	["ninety-four"] = 94,
	["ninety-five"] = 95,
	["ninety-six"] = 96,
	["ninety-seven"] = 97,
	["ninety-eight"] = 98,
	["ninety-nine"] = 99,
	["one hundred"] = 100,
	["two hundred"] = 200,
	["three hundred"] = 300,
	["four hundred"] = 400,
	["five hundred"] = 500,
	["six hundred"] = 600,
	["seven hundred"] = 700,
	["eight hundred"] = 800,
	["nine hundred"] = 900,
	["one thousand"] = 1000,
	["two thousand"] = 2000,
	["three thousand"] = 3000,
	["four thousand"] = 4000,
	["five thousand"] = 5000,
	["six thousand"] = 6000,
	["seven thousand"] = 7000,
	["eight thousand"] = 8000,
	["nine thousand"] = 9000,
}
--#endregion

--#region General functions
function string.isEmpty(s)
	return s == nil or s == ""
end

function string.toTable(s, delimiter)
	local result = {}
	if type(s) == "string" and type(delimiter) == "string" then
		for match in (s..delimiter):gmatch("(.-)"..delimiter) do
			table.insert(result, match)
		end
	end
	return result
end

function string.replaceLast(originalString, matchString, replaceString)
	local searchString = string.reverse(matchString)
	local stringReversed = string.reverse(originalString)
	local stringIndex = string.find(stringReversed, searchString)
	local editedReveresString = string.sub(stringReversed, 0, stringIndex) .. replaceString .. string.sub(stringReversed, stringIndex + string.len(searchString))
	return string.reverse(editedReveresString)
end

function string.trim(s)
	if type(s) == "string" then
		return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
	end
	return s
end

function table.filter(table,prop,val)
	local returnTable = {}
	for key, value in pairs(table) do
		if string.lower(value[prop]) == string.lower(val) then
			returnTable[key] = value
		end
	end
	return returnTable
end

function table.contains(t, match)
	for i = 1, #t, 1 do
		if t[i] == match then
			return true
		end
	end
	return false
end

function table.isEmpty(t)
	if type(t) == "table" then
		if not next(t) then
			return true
		end
	end
	return false
end

function table.length(t)
	local total = 0
	for x in pairs(t) do
		total = total + 1
	end
	return total
end

function table.print(t)
	for k,v in pairs(t) do
		local vType = type(v)
		if vType == "table" then
			Note(k)
			table.print(v)
		else
			ColourTell("#0080FF", "", k .. ": ")
			ColourTell("#7DE800", "", v)
			Note("")
		end
	end
end

function table.unique(t)
	local result = {}
	for i = 1, #t, 1 do
		if not table.contains(result, t[i]) then
			table.insert(result, t[i])
		end
	end
	return result
end
--#endregion

--#region Vault functions
function VaultConvertContentsTableToArray(table)
	local result = {}
	for i = 1, #table, 1 do
		local contentString = string.toTable(table[i],"*")
		result[contentString[1]] = contentString[2]
	end
--	table.print(result)
	return result
end

function VaultConvertContentStringToArray(s)
	s = ", " .. s
	if string.match(s, " and ") then
		s = string.replaceLast(s, " and ", ", ")
	end

	-- Find unique Items with capital letters and quantify them
	while s.find(s, ", %u") do
		local matchIndex = string.find(s, ", %u")
		s = string.sub(s, 1, matchIndex) .. " a" .. string.sub(s, matchIndex+1, string.len(s))
	end

	-- quantify non-numeric quantifiers
	s = string.gsub(s, ", many ", ";, 20*")
	s = string.gsub(s, ", some ", ";, 1*")
	s = string.gsub(s, ", the ", ";, 1*")
	s = string.gsub(s, ", an ", ";, 1*")
	s = string.gsub(s, ", a ", ";, 1*")

	-- prepare string to be split
	for key, value in pairs(numberWords) do
		s = string.gsub(s, ", " .. key .. " ", ";, " .. value .. "*")
	end

	-- unprepare items with a comma
	for index, value in ipairs(itemsWithComma) do
		local seatchString = string.gsub(value, ", ", ";, ")
		s = string.gsub(s, seatchString, value)
	end

	s = string.gsub(s, ";, ", "", 1)
	local contentTable = string.toTable(s, ";,")
	local contentArray = {}

	for i = 1, #contentTable, 1 do
		contentTable[i] = string.trim(contentTable[i])
		local fooTable = string.toTable(contentTable[i],"*")
		local singleItem = via1qlazjpn7hexysgk8p868qhhlljnkcxzyycxl9h8(fooTable[2])
		contentArray[singleItem] = fooTable[1]
	end

	return contentArray
end

function via1qlazjpn7hexysgk8p868qhhlljnkcxzyycxl9h8(s)
	local result = s

	result = result:gsub("pairs of", "pair of")
	result = result:gsub("chunks", "chunk")
	result = result:gsub("sides", "side")
	result = result:gsub("knives", "knife")
	result = result:gsub("pirates'", "pirate's")

	if not string.find(result, "pair of") then
		local fooTable = string.toTable(result, " ")
		local lastWord = fooTable[#fooTable]
		local isSingularWord = false
		local singularWordEndsInE = false
		local removeES = false
		local removeS = false

		-- plural word (ending in s or es) is actually a singular word
		if (string.sub(lastWord, string.len(lastWord)-1) == "es") and (isSingularWord == false) then
			for i = 1, #itemsEndingInES, 1 do
				if itemsEndingInES[i] == lastWord then
					isSingularWord = true
					i = #itemsEndingInES
				end
			end
		end
		if (string.sub(lastWord, string.len(lastWord)) == "s") and (isSingularWord == false) then
			for i = 1, #itemsEndingInS, 1 do
				if itemsEndingInS[i] == lastWord then
					isSingularWord = true
					i = #itemsEndingInS
				end
			end
		end

		-- Is singular word ending with e?
		if (string.sub(lastWord, string.len(lastWord)-1) == "es") and (isSingularWord == false) then
			local lastWordEndingInE = string.sub(lastWord, 0, string.len(lastWord)-1)
			for i = 1, #itemsEndingInE, 1 do
				if itemsEndingInE[i] == lastWordEndingInE then
					singularWordEndsInE = true
					i = #itemsEndingInE
				end
			end
		end

		if (string.sub(lastWord, string.len(lastWord)-1) == "es") and (isSingularWord == false) and (singularWordEndsInE == false) then
			removeES = true
		end

		if (string.sub(lastWord, string.len(lastWord)) == "s") and (isSingularWord == false) and (singularWordEndsInE == false) and (removeES == false) then
			removeS = true
		end

		if isSingularWord then
			result = result
		elseif singularWordEndsInE then
			result = string.sub(result, 0, string.len(result)-1)
		elseif removeES then
			result = string.sub(result, 0, string.len(result)-2)
		elseif removeS then
			result = string.sub(result, 0, string.len(result)-1)
		end
	end
	return result
end

function VaultGetAllVaultContentItemsAsTable()
	local vaultContentsArray = VaultGetVaultContentsArray()
	local allVaultContents = {}
	for k, v in pairs(vaultContentsArray) do
		for key, value in pairs(v) do
			allVaultContents[key] = 0
		end
	end

	for k, v in pairs(vaultContentsArray) do
		for key, value in pairs(v) do
			allVaultContents[key] = allVaultContents[key] + tonumber(value)
		end
	end

	return allVaultContents
end

function VaultGetSpecificItemsByVault(vaultName, itemName)
	if type(vaultName) ~= "string" then
		Note("vaultName is not a string")
	elseif type(itemName) ~= "string" then
		Note("itemName is not a string")
	else
		local vaultContents = VaultGetVaultContentsArrayByVault(vaultName)
		vaultContents = table.sort(vaultContents, function(k1, k2) return k1 < k2 end)
		for key, value in pairs(vaultContents) do
			Note(key .. ": " .. value)
		end
	end
end

function VaultGetVaultContentsArray()
	local result = {}
	local vaultContentsTable = VaultGetVaultContentsTable()
	if type(vaultContentsTable) == "table" then
		for i=1, #vaultContentsTable, 1 do
			local arrayTable = string.toTable(vaultContentsTable[i], ";")
			local contentTable = string.toTable(arrayTable[2], "|")
			table.sort(contentTable, function (a, b)
				return string.lower(a) < string.lower(b)
			end)
			result[arrayTable[1]] = VaultConvertContentsTableToArray(contentTable)
		end
	end
	return result
end

function VaultGetVaultContentsArrayByVault(vaultName)
	local vaultContentsArray = VaultGetVaultContentsArray()
	for key, value in pairs(vaultContentsArray) do
		if string.lower(key) == string.lower(vaultName) then
			return value
		end
	end
end

function VaultGetVaultContentsTable()
	local result = {}
	local vaultContentsString = VaultGetVaultContents()
	if type(vaultContentsString) == "string" then
		result = string.toTable(vaultContentsString, "/")
	end
	return result
end

function VaultGetVaultsContainingItem(item)
	local contentsArray = VaultGetVaultContentsArray()
	local matchVaults = {}
	
	for key, value in pairs(contentsArray) do
		for k, v in pairs(value) do
			if string.find(string.lower(k), string.lower(item)) then
				table.insert(matchVaults, key)
			end
		end
	end
	
	return table.unique(matchVaults)
end

function VaultPrintAllVaults()
	local totalAmount = table.length(vaults)
	for i = 1, totalAmount, 1 do
		for k, v in pairs(vaults) do
			if v["order"] == i then
				VaultPrintVaultInfoByVault(k)
			end
		end
	end
end

function VaultPrintAnyHasItem(item)
	if type(item) ~= "string" then
		Note("item is not a string")
	elseif string.len(item) < 3 then
		Note("Enter at least 3 letters to get more accurate results.")
	else
		local matchVaultTable = VaultGetVaultsContainingItem(item)
		if(#matchVaultTable == 0) then
			Note("No vault contains " .. item .. ".")
		else
			for i = 1, #matchVaultTable, 1 do
				local vault = vaults[matchVaultTable[i]]
				Tell("[")
				Tell(Hyperlink("vaultcontent " .. matchVaultTable[i], "Show contents", "Show contents of " .. matchVaultTable[i], "#FF8C00", "black", 0))
				Tell("]")
				Tell(" ")
				ColourTell("red", "", vault.city)
				Tell(": " .. matchVaultTable[i] .. " (costs ")
				ColourTell("yellow", "", vault.cost)
				Tell(") ")
				ColourTell("#0080FF", "", "[")
				ColourTell(Hyperlink("minimap " .. matchVaultTable[i], "Go to", "Automove to " .. matchVaultTable[i], "#FF8C00", "black", 0))
				ColourTell("#0080FF", "", "]")
				Note("")
				
				local vaultContents = VaultGetVaultContentsArrayByVault(matchVaultTable[i])
				for key, value in pairs(vaultContents) do
					if string.match(string.lower(key), string.lower(item)) then
						ColourTell("#0080FF", "", "- ")
						Tell(key .. ": " .. value)
						ColourTell("#0080FF", "", " [")
						ColourTell(Hyperlink("\nwait\ntake 1 " .. key .. " from " .. vault.container .. "\nlook " .. vault.container, "take one", "take one " .. key .. " from " .. vault.container, "#FF8C00", "black", 0))
						ColourTell("#0080FF", "", "] ")
						Note()
					end
				end
			end
		end
	end
end

function VaultPrintVaultInfoByVault(vaultName)
	local vault = vaults[vaultName]
	local vaultContents = VaultGetVaultContentsArrayByVault(vaultName)
	if type(vaultContents) == "table" then
		Tell("[")
		Tell(Hyperlink("vaultcontent " .. vaultName, "Show contents", "Show contents of " .. vaultName, "#FF8C00", "black", 0))
		Tell("]")
		Tell(" ")
	end

	ColourTell("red", "", vault.city)
	Tell(": " .. vaultName .. " (costs ")
	ColourTell("yellow", "", vault.cost)
	Tell(")")
	Tell(" ")
	Tell("[")
	Tell(Hyperlink("minimap " .. vaultName, "Go to " .. vaultName, "Automove", "#FF8C00", "black", 0))
	Tell("]")
	Note("")
end

function VaultPrintConsolidatedVaultContents()
	ColourNote("yellow", "", "All vaults' contents:")
	VaultPrintContentsArray(VaultGetAllVaultContentItemsAsTable())
end

function VaultPrintVaultContents(vaultName)
	ColourNote("yellow", "", string.upper(vaultName))
	VaultPrintContentsArray(VaultGetVaultContentsArrayByVault(vaultName))
end

function VaultPrintContentsArray(array)
	local contentsTable = {}
	for key, value in pairs(array) do
		table.insert(contentsTable, {name = key, amount = value})
	end
	table.sort(contentsTable, function (k1,k2) return string.lower(k1.name) < string.lower(k2.name) end)
	for index, value in ipairs(contentsTable) do
		ColourTell("#0080FF", "", value.name .. ": ")
		ColourTell("#7DE800", "", value.amount)
		Note("")
	end
end
--#endregion

--#region Process Trigger functions
function VaultProcessTriggerContents(name, output, wildcards)
	local vaultContents = VaultGetVaultContentsArray()
	if table.isEmpty(vaultContents) then
		vaultContents = {}
	end

	local contentString = wildcards[4]
	local contentsArray = VaultConvertContentStringToArray(contentString)
	local currentVault = VaultGetVaultCurrent()

	vaultContents[currentVault] = contentsArray
	
	VaultSetVaultContentsArray(vaultContents)
end

function VaultProcessTriggerCurrent(name, output, wildcards)
	VaultSetVaultCurrent(wildcards[1])
end
--#endregion

--#region Process Alias functions
function VaultProcessAliasVaultCheckAll(name, output, wildcards)
	VaultPrintConsolidatedVaultContents()
end

function VaultProcessAliasVaultCheckAllVaults(name, output, wildcards)
	VaultPrintAllVaults()
end

function VaultProcessAliasVaultCheckAnyHasItem(name, output, wildcards)
	local item = wildcards[1]
	VaultPrintAnyHasItem(item)
end

function VaultProcessAliasVaultContent(name, output, wildcards)
	local vaultName = wildcards[1]
	VaultPrintVaultContents(vaultName)
end
--#endregion

--#region Variable functions
function VaultGetVaultContents()
	local result = GetVariable("vaultContents")
	if string.isEmpty(result) then
		result = ""
	end
	return result
end

function VaultGetVaultCurrent()
	local result = GetVariable("vaultCurrent")
	if string.isEmpty(result) then
		result = ""
	end
	return result
end

function VaultSetVaultContentsArray(a)
	if type(a) == "table" then
		local result = ""

		if not table.isEmpty(a) then
			local resultTable = {}
			for key, value in pairs(a) do
				local fooTable1 = {}
				for k, v in pairs(value) do
					table.insert(fooTable1, k.."*"..v)
				end
				table.sort(fooTable1, function (k1,k2) return string.lower(k1) < string.lower(k2) end)
				local resultString = table.concat(fooTable1,"|")
				table.insert(resultTable,key .. ";" .. resultString)
			end
			result = table.concat(resultTable, "/")
		end
		VaultSetVaultContents(result)
	else
		ColourNote("red", "", "VaultSetVaultContentsArray error: input is not an table")
	end
end

function VaultSetVaultContents(s)
	if type(s) == "string" then
		SetVariable("vaultContents", s)
	else
		ColourNote("red", "", "VaultSetVaultContents error: input is not a string")
	end
end

function VaultSetVaultCurrent(string)
	SetVariable("vaultCurrent", string)
end
--#endregion
]]>
</script>

<!--  Triggers  -->
<triggers>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent1"
		group="vaults"
		match="^\[(Nella\'s vault)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent2"
		group="vaults"
		match="^\[(cool, dry basement)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent3"
		group="vaults"
		match="^\[(safety deposit waiting room)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent4"
		group="vaults"
		match="^\[(Thella\'s vault)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent5"
		group="vaults"
		match="^\[(small garden)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent6"
		group="vaults"
		match="^\[(opulent office)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetCurrent7"
		group="vaults"
		match="^\[(office in Ohulan-Cutash)\]$"
		script="VaultProcessTriggerCurrent"
		sequence="100"
	>
	</trigger>
	<trigger
		enabled="y"
		regexp="y"
		name="lblVaultSetContent"
		group="vaults"
		match="The (drawer|large wooden drawer|steel locker|cubby hole|octiron tesseract|clean nest) is (almost empty except for|almost full|over-full|almost completely full|completely full|about .+ full)( with)? (.+)\."
		script="VaultProcessTriggerContents"
		sequence="100"
	>
	</trigger>
</triggers>

<!--  Aliases  -->
<aliases>
	<alias
		enabled="y"
		regexp="y"
		ignore_case="y"
		name="lblVaultCheckAllVaults"
		group="vaults"
		match="^vaults?$"
		script="VaultProcessAliasVaultCheckAllVaults"
		sequence="100"
	>
	</alias>
	<alias
		enabled="y"
		regexp="y"
		ignore_case="y"
		name="lblVaultCheckAnyHasItem"
		group="vaults"
		match="^vaults? (.*)$"
		script="VaultProcessAliasVaultCheckAnyHasItem"
		sequence="100"
	>
	</alias>
	<alias
		enabled="y"
		regexp="y"
		ignore_case="y"
		name="lblVaultCheckAll"
		group="vaults"
		match="^vaults?all$"
		script="VaultProcessAliasVaultCheckAll"
		sequence="100"
	>
	</alias>
	<alias
		enabled="y"
		regexp="y"
		ignore_case="y"
		name="lblVaultContent"
		group="vaults"
		match="^vaults?content (.+)$"
		script="VaultProcessAliasVaultContent"
		sequence="100"
	>
	</alias>
</aliases>

<!--  Timers  -->
<timers>
</timers>

</muclient>